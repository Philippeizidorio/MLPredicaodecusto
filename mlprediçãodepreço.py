# -*- coding: utf-8 -*-
"""MLPrediçãodepreço.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SET55PJ7WsktLkl4aK3n7g9Zbn3ZwKHl
"""

# Commented out IPython magic to ensure Python compatibility.
#importando e instalando bibliotecas
import pandas as pnd
# %pip install plotly
# %pip install cufflinks
# %pip install chart-studio
import seaborn as sns
import numpy as np
import chart_studio.plotly as py
import cufflinks as cf
import plotly.graph_objects as go
import plotly.express as px

#importando base
base_c = pnd.read_csv("/content/USA_Housing.csv", sep=",")
base_c.head()

#verificando se há nulos
base_c.info()

#pegando colunas para aplicar rename
base_c.columns

#Dando um rename para substitui espaços nas colunas
base_c = base_c.rename(columns={'Avg. Area Income':'Avg_Area_Income', 'Avg. Area House Age':"Avg_Area_House_Age", 'Avg. Area Number of Rooms':'Avg_Area_Number_of_Rooms',
       'Avg. Area Number of Bedrooms':'Avg_Area_Number_of_Bedrooms', 'Area Population':'Area_Population'})
base_c.head()

#dropando a coluna 'Address' - Não precisaremos de variáveis de texto neste caso-.
base_c.drop(["Address"], axis=1, inplace=True)
base_c.head()

#Analisando o dataset com describe
base_c.describe()

#Analisando a coluna "Avg.Area Income" com boxplot
fig = px.box(base_c, x="Avg_Area_Income")
fig.update_traces(line_color="blue")

#Analisando a coluna "Avg_Area_Number_of_Rooms" com boxplot
fig = px.box(base_c, x="Avg_Area_Number_of_Rooms")
fig.update_traces(line_color="blue")

#Importando seaborn para plotar gráficos
import seaborn as sns

#Plotando Pairplot para vermos a correlação de uma coluna com ela mesma e as demais do dataset
sns.pairplot(base_c)

#Puxando colunas para especificar 'x' e 'y'
base_c.columns

#Especificando as variáveis para ver a correlação somente com preço
sns.pairplot(base_c, x_vars=['Avg_Area_Income', 'Avg_Area_House_Age', 'Avg_Area_Number_of_Rooms',
       'Avg_Area_Number_of_Bedrooms', 'Area_Population'], y_vars='Price')
#Aqui vemos que as colunas possuem uma maior correlação positiva com 'price' são a número 1,2,3 e 5, tendo em vista crescimento contínuo

#Entendendo a correlação em números
#As correlações vão de 1 até -1
#Quanto mais próxima de zero, indica corr.nula (ex: 0.01,-0.002...)
#Quanto mais próxima de 1, indica corr.positiva (ex: 0.3,0.7.,0.9, abaixo de 0.3 é fraca)
#Quanto mais próximo de -1, indica corr.negativa (ex: -0.3, -0.7, -0.9, abaixo de -0,3 é fraca)
base_c.corr()

#Plotando heatmap para vermos visualmente as correlações com 'price'
sns.heatmap(base_c.corr(), annot=True)

#Checando a distribuição do preço
sns.histplot(base_c["Price"])

#Pegando as colunas para separar as variáveis 'x' e 'y'
base_c.columns

#Separando as variáveis
x = base_c[['Avg_Area_Income', 'Avg_Area_House_Age', 'Avg_Area_Number_of_Rooms',
       'Avg_Area_Number_of_Bedrooms', 'Area_Population']]

y = base_c[["Price"]]

#importanto biblioteca de ML e definindo novas bases de treino e teste
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, train_size=0.7, test_size=0.3, random_state=42)

#Verificando tamanho das bases
#70% vai para as bases de treino(aprendizado) e 30% vai pras bases de teste(onde ela aplica o aprendizado das bases train)
print(x_train.shape)
print(x_test.shape)
print(y_train.shape)
print(y_test.shape)

#importando regressão linear do Sklearn
from sklearn.linear_model import LinearRegression

#Dando um nome qualquer a variável para chamar a função LinearRegressiom
ln = LinearRegression()

#Momento de treinar os dados com regressão linear
ln.fit(x_train, y_train)

#Após treinado, vamos predizer o 'y' com base no 'x_test' usando função .predict()
y_pred = ln.predict(x_test)

#trazendo métrica R² Score do sklearn para medir a qualidade da correlação
from sklearn.metrics import r2_score
rscore = r2_score(y_test, y_pred)

#Imprimindo a qualidade na correlação entre os valores da base 'y_test' e os preditos em 'x_test'
print("O R² é de:", rscore)

#importando matplotlib para plotar o y_test e comparar com as predições y_pred
import matplotlib.pyplot as plt

#plotando gráfico da comparação de y_test(base atual) e as predições de y_pred
c = [i for i in range(1,1501,1)]
fig = plt.figure(figsize=(10,8))
plt.plot(c, y_test, color="blue")
plt.plot(c, y_pred, color="red")
plt.xlabel("Index ou Linha")
plt.ylabel("Preço Do Imóvel")

#Retomando colunas
base_c.columns

base_c.describe()

#Premissas do Philippe para prever o preço
Avg_Area_Income = 60000
Avg_Area_House_Age = 10
Avg_Area_Number_of_Rooms = 5
Avg_Area_Number_of_Bedrooms = 3
Area_Population = 2000
entrada = [[Avg_Area_Income,Avg_Area_House_Age, Avg_Area_Number_of_Rooms, Avg_Area_Number_of_Bedrooms, Area_Population]]
prever = ln.predict(entrada)[0][0]
print(f'O preço é de: ${prever:.2f}')